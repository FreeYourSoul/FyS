// MIT License
//
// Copyright (c) 2019 Quentin Balland
// Repository : https://github.com/FreeYourSoul/FyS
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
//         of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
//         to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//         copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
//         copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//         AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include <exchange/exchange_manager.hh>
#include <flatbuffer_generator.hh>
#include <inventory_server_context.hh>

namespace fys::inv {

exchange_manager::exchange_manager(const inventory_server_context& ctx)
    : common::direct_connection_manager(1, ctx.get_player_connection_str()),
      _inventory_server_code(ctx.server_code()) {}

const exchange_room&
exchange_manager::makeExchangeRoom(item_manager& itemManager, std::string initiator, std::string receiver, std::string identity) {
  // The identity with the initiator of the exchange transaction is used as base for the token
  // used for the the transaction. It is a string randomly generated by ZMQ that is more or less
  // a UUID.  Which makes it a perfect candidate for being used that way.
  auto newRoom = exchange_room(_current_room_id, std::move(initiator), std::move(receiver),
                               std::move(identity), generate_token(identity), itemManager);

  // insert a new Exchange room in the current transactions
  _rooms.insert(std::pair(_current_room_id, std::move(newRoom)));

  // increment id for next exchange room
  return _rooms.at(_current_room_id++);
}

void exchange_manager::terminate_room_transaction(item_manager& manager, const room_accessor& accessor) {

  // remove room from current transactions
  _rooms.erase(accessor.idExchange);
}

void exchange_manager::lock_room_transaction(const room_accessor& accessor) {
  auto it = _rooms.find(accessor.idExchange);
  if (it != _rooms.end()) {
    it->second.lockExchange(accessor.userName, accessor.tokenExchange);
  } else {
    SPDLOG_ERROR("[Exchange : Room {}] Doesn't exist", accessor.idExchange);
  }
}

void exchange_manager::remove_item_from_room(item_manager& manager, const room_accessor& accessor,
                                             const std::string& item_code, std::uint32_t qty) {
  auto it = _rooms.find(accessor.idExchange);
  if (it != _rooms.end()) {
    it->second.removeItemFromExchangeForPlayer(accessor.userName, accessor.tokenExchange, Item{item_code, qty});
  } else {
    SPDLOG_ERROR("[Exchange : Room {}] Doesn't exist", accessor.idExchange);
  }
}

void exchange_manager::add_item_in_room(item_manager& manager, const room_accessor& accessor,
                                        const std::string& item_code, std::uint32_t qty) {
  auto it = _rooms.find(accessor.idExchange);
  if (it != _rooms.end()) {
    it->second.addItemFromExchangeForPlayer(accessor.userName, accessor.tokenExchange, Item{item_code, qty});
  } else {
    SPDLOG_ERROR("[Exchange : Room {}] Doesn't exist", accessor.idExchange);
  }
}

void exchange_manager::receiver_join_room_transaction(const room_accessor& accessor, std::string identity_receiver) {
  auto it = _rooms.find(accessor.idExchange);
  if (it != _rooms.end()) {
    it->second.receiverJoin(accessor.userName, accessor.tokenExchange, std::move(identity_receiver));
  } else {
    SPDLOG_ERROR("[Exchange : Room {}] Doesn't exist", accessor.idExchange);
  }
}

std::string
exchange_manager::generate_token(const std::string& token_base) const {
  return std::to_string(_current_room_id).append(_inventory_server_code).append(token_base);
}

}// namespace fys::inv